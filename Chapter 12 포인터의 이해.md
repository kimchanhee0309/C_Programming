<details>
<summary>12-1. 포인터란 무엇인가?</summary>
<div markdown="1">       

#### 주소 값의 저장을 목적으로 선언되는 포인터 변수
* 1바이트의 메모리 공간을 단위로 하나의 주소 값이 할당되며, 주소 값도 1씩 증가함
* C언어에서는 시작번지만을 가지고 위치를 표현함
* 주소 값 또한 정수이기 때문이 저장이 가능한 값이며, 이의 저장을 위해 마련된 변수가 바로 **'포인터 변수'** 임
  * 즉, `포인터 변수`란, 메모리의 주소 값을 저장하기 위한 변수를 뜻함

#### 포인터 변수와 &연산자에 대해서 간단히 맛보기!
```C
int main(void)
{
  int num=7;  
  int *pnum;   // 포인터 변수 pnum의 선언
  punm = &num; // num의 주소 값을 포인터 변수 pnum에 저장
  . . . .
```
* 정수 7이 저장된 int형 변수 num을 선언하고 이 변수의 주소 값 저장을 위한 포인터 변수 pnum을 선언
* 그 후, pnum에 변수 num의 주소 값을 저장
* &연산자 : '오른쪽에 등장하는 **피연산자의 주소 값을 반환하는** 연산자
* 포인터 변수 pnum에는 변수 num의 시작번지 주소 값이 저장됨
* 즉, 포인터 변수 pnum이 int형 변수 num을 가리킨다고 표현할 수 있음

#### 포인터 변수 선언하기
* 포인터 변수는 가리키고자 하는 변수의 자료형에 따라서 선언하는 방법이 달라짐
* 포인터 변수의 선언형태만 보고도 이 포인터가 현재 가리키는 변수의 자료형을 짐작할 수 있음

#### 포인터의 형(Type)
* 포인터 변수의 선언 및 구분에 사용되는 int *, char *, double * 등을 가리켜 **'포인터 형(type)'** 이라고 함
* But, 포인터 변수도 값을 저장하는 변수이기 때문에 '포인터 형' 역시 '자료형'의 범주에 포함시키기도 함
```C
int *        // int형 포인터
int * pnum1; // int형 포인터 변수 pnum1

double *        // double형 포인터
double * pnum2; // double형 포인터 변수 pnum2
```
</div>
</details>

___

<details>
<summary>12-2. 포인터와 관련 있는 연산자: &연산자 *연산자</summary>
<div markdown="1">       

#### 변수의 주소 값을 반환하는 &연산자
* `&연산자`는 **피연산자의 주소 값을 반환**하는 연산자임
* `&연산자`의 피연산자는 변수이어야 하며, **상수는 피연산자가 될 수 없음**
```C
int main(void)
{
  int num = 5;
  int * pnum = &num; // num의 주소 값을 반환해서 포인터 변수 pnum을 초기화
  . . . .
}
```

* 변수의 자료형에 맞지 않는 포인터 변수의 선언은 문제가 될 수 있음
```C
int main(void)
{
  int num1 = 5;
  double * punm1 = &num1;  // 일치하지 않음

  double num2 = 5;
  int * pnum2 = &num2;  // 일치하지 않음
  . . . .
}
```

#### 포인터가 가리키는 메모리를 참조하는 *연산자
* `*연산자`는 **포인터가 가리키는 메모리 공간에 접근할 때 사용**하는 연산자임
```C
int main(void)
{
  int num=10;
  int * punm=&num;     // 포인터 변수 pnum이 변수 num을 가리키게 하는 문장
  *pnum=20;            // 포인터 변수 pnum이 가리키는 메모리 공간인 변수 num에 20을 저장하라!
  printf("%d", *pnum); // 포인터 변수 pnum이 가리키는 메모리 공간인 변수 num에 저장된 값을 출력하라!
  . . . .
}
```

#### 다양한 '포인터 형'이 존재하는 이유!
* 포인터의 형은 **메모리 공간을 참조하는 기준**이 됨
* 즉, 포인터 형을 정의한 이유는 *연산자를 통한 메모리 공간의 접근 기준을 마련하기 위함임
* 포인터에 형이 존재하지 않는다면 *연산을 통한 메모리의 접근이 불가능함

#### 잘못된 포인터의 사용과 널 포인터
* 포인터 변수에는 메모리의 주소 값이 저장되고, 이를 이용해서 해당 메모리 공가넹 접근도 가능하기 때문에 포인터와 관련해서는 상당히 주의를 해야함
* 포인터가 잘못 사용된 예시
```C
int main(void)
{
  int * ptr; //포인터 변수 ptr은 쓰레기 값으로 초기화 됨
  *ptr=20;
  . . . .
}

//포인터 변수를 선언만하고 초기화하지 않으면, 포인터 변수는 쓰레기 값으로 초기화 됨. 즉 어디를 가리킬지 모르게 되는 것!
//ptr이 가리키는 위치가 어디인 줄도 모르는데 값을 저장하면 문제가 발생할 수 있음
```
```C
int main(void)
{
  int * ptr=125; //125번지가 어딘 줄 알고?
  *ptr=10;
  . . . .
}

//포인터 변수 ptr을 초기화 한답시고 125를 저장함
//But, 125번지가 어딘 줄 알고 포인터 변수를 125로 초기화? 이는 쓰레기 값으로 포인터 변수를 초기화한 것과 다르지 않음
```

* 위 두 사례의 문제를 해결하는 포인터 변수 초기화 방법
  * 포인터 변수를 선언만 해 놓고, 이후에 유효한 주소 값을 채워 넣을 생각인 경우에는 다음과 같이 초기화 하는 것이 좋음
```C
int main(void)
{
  int * ptr1=0;
  int * ptr2=NULL;  //NULL은 사실상 0을 의미함
  . . . .
}
```
* ptr1을 초기화하는 값 0 = 널 포인터라고 칭함
* 널 포인터? 아무데도 가리키지 않는다고 선언하는 것과 같음
</div>
</details>
